
#import "Net"
#import "Logger"
#import "OS"
#import "Threads"
#import "backend"

struct Session {
    server: Server;
    job_system: JobSystem*;
}

fn start_webserver() {
    port: i32 = 8080
    
    session: Session;
    session.job_system = InitJobSystem("data")
    
    session.server.set_callback(handle_event, &session)
    err := session.server.start(port)
    
    log("Started server at port ",port)
    
    fn handle_event(e: Event, user_data: void*) {
        session := cast<Session*>user_data
        server := &session.server
        if e.type == EVENT_RECEIVE {
            // log("Event recv:")
            // log(e.bytes)
            //#################
            //  PARSE HEADER
            // ################
            msg := e.bytes
            
            head := 0
            
            if substring(msg,0,4) == "GET " {
                head += 4
            } else substring(msg,0,5) == "POST " {
                head += 5
            } else {
                log("missing GET or POST")
                return;
            }
            
            path_start := head
            while head < msg.len {
                chr := msg[head]
                head++
                if chr == ' ' || chr == '\n' || chr == '\r' || chr == '\t'
                    break
            }
            
            url: StringBuilder
            defer url.cleanup()
            url.append(substring(msg,path_start,head-1))
            
            version := "HTTP/1.1\r\n"
            if substring(msg,head,head + version.len) != version {
                log("missing HTTP/1.1, or path was bad '",url,"'")
                return;
            }
            head += version.len
            
            fields: Array<char[]>
            defer fields.cleanup
            field_start := 0
            while {
                chr := msg[head]
                chr2: char
                if head+1 < msg.len
                    chr2 = msg[head+1]
                head++
                
                if chr == '\r' && chr2 == '\n' {
                    if field_start + 1 == head // reached final newline
                        break
                    
                    fields.add(substring(msg, field_start, head))
                    
                    head++
                    field_start = head
                }
            }
            content_length: i32
            content_data: char* = msg + head;
            for fields.sliced() {
                pair := split(":", it)
                defer pair.cleanup()
                
                if pair.size() != 2
                    continue
                key := pair.get(0)
                val := pair.get(1)
                if key == "Content-Length" {
                    value_str := substring(val, 1)
                    content_length = parse_i64(value_str)
                }
            }
            
            // log("get ",path)

            // calculate options
            index := find("?", url)
            // log(url, " ", index)

            option_part := substring(url, index + 1)
            
            options_str := split("&", option_part)
            option_id: char[] = {}
            for options_str.sliced() {
                pair := split("=", it)
                defer pair.cleanup()
                if pair.len != 2
                    continue
                if pair[0] == "id" {
                    option_id = pair[1]
                    // log("id=",pair[1])
                }
            }

            path := substring(url, 0, index)
            
            // log(url, " ",path)
            
            // ##########
            //  RESPOND
            // ##########
            
            if !IsPathSanitized(path) {
                // log("path is not safe")
                return;   
            }
            
            if path == "/api/create" {
                
                content: char[] = {content_data, content_length}
                
                fields_loop := split("\n", content)
                defer fields.cleanup()
                name: char[]
                desc: char[]
                for fields.sliced() {
                    
                }
                
                session.job_system.create_job(name, desc)
                
                response: StringBuilder
                defer response.cleanup()
                
                response.append("HTTP/1.1 200 OK\r\n")
                response.append("Content-Length: 0\r\n")
                response.append("Connection: close\r\n")
                response.append("\r\n")
            } else if path == "/api/get" {
                // TODO: check if parse failed
                id: i32 = parse_i64(option_id)
                
                job := session.job_system.find_job(id)
                
                response: StringBuilder
                defer response.cleanup()
                
                if !job {
                    response.append("HTTP/1.1 404 Not Found\r\n")
                    response.append("Connection: close\r\n")
                    response.append("\r\n")
                        
                    server.send<char>(response.sliced(), who = e.who)
                    return;
                }
                
                data: StringBuilder
                defer data.cleanup()
                
                data.append("{")
                
                #macro FIELD(K,V)
                data.append("\"")
                data.append(K)
                data.append("\":")
                data.append(V)
                data.append(",")
                #endmacro
                #macro FIELD_S(K,V)
                data.append("\"")
                data.append(K)
                data.append("\":")
                data.append("\"")
                data.append(V)
                data.append("\"")
                data.append(",")
                #endmacro
                
                FIELD_S("name", job.name)
                FIELD("id", job.id)
                FIELD_S("description", job.description)
                FIELD("created",  cast<i64>job.created)
                FIELD("started",  cast<i64>job.started)
                FIELD("finished", cast<i64>job.finished)
                FIELD("output_handle", cast<i32>job.output_handle)
                
                data.append("}")
                
                response.append("HTTP/1.1 200 OK\r\n")
                response.append("Content-Length: ")
                response.append(data.size())
                response.append("\r\n")
                response.append("Connection: close\r\n")
                response.append("\r\n")
                
                response.append(data)
                
                server.send<char>(response.sliced(), who = e.who)
                return;
            } else  if path == "/api/list" {
                data: StringBuilder
                defer data.cleanup()
                
                data.append("{")
                data.append("\"jobs\":[")
                
                for @ptr session.job_system.jobs.sliced() {
                    if nr != 0
                        data.append(",")
                    
                    data.append("{")
                    data.append("\"id\":")
                    data.append(it.id)
                    data.append(",")
                    data.append("\"name\":")
                    data.append("\"")
                    data.append(it.name)
                    data.append("\"")
                    data.append("}")
                }
                
                data.append("]}")
                
                response: StringBuilder
                response.append("HTTP/1.1 200 OK\r\n")
                response.append("Content-Length: ")
                response.append(data.size())
                response.append("\r\n")
                response.append("Connection: close\r\n")
                response.append("\r\n")
                
                response.append(data)
                
                server.send<char>(response.sliced(), who = e.who)
                return;
            }
            
            real_path: StringBuilder
            defer real_path.cleanup()
            real_path.append("public")
            if(path[0] == '/') {
                if path == "/" {
                    real_path.append("/index.html")
                } else {
                    real_path.append(path)
                }
            } else {
                return; // suspicious, path in header always begins with slash
            }
            
            response: StringBuilder
            defer response.cleanup()
            
            filesize: i64
            file := FileOpen(real_path, FILE_READ_ONLY, &filesize)
            if !file {
                response.append("HTTP/1.1 404 Not Found\r\n")
                response.append("Connection: close\r\n")
                response.append("\r\n")
                // log("send: Not Found")
            } else {
                defer FileClose(file)
                
                response.append("HTTP/1.1 200 OK\r\n")
                response.append("Content-Length: ")
                response.append(filesize)
                response.append("\r\n")
                response.append("Connection: close\r\n")
                response.append("\r\n")
                
                header_len := response.len
                response.resize(header_len + filesize)
                
                err := FileRead(file, response.ptr + header_len, filesize)
                if !err {
                    log("FileRead failed on ", real_path)
                    // TODO: Send back error
                    return;
                }
                // log("send: ",real_path)
            }
            
            server.send<char>(response.sliced(), who = e.who)
        }
    }
    
    session.server.wait()
    session.server.close()
}

fn IsPathSanitized(path: char[]) -> bool {
    // Crude sanitization
    if path.ptr[0] != '/'
       return false
    for 1..path.len {
        chr := path[nr]
        if path.ptr[nr-1] == '.' && chr == '.'
            return false
        if chr >= '0' && chr <= '9'
            continue
        if chr >= 'A' && chr <= 'Z'
            continue
        if chr >= 'a' && chr <= 'z'
            continue
        if chr == '_' || chr == '-' || chr == '-' || chr == '.' || chr == '/'
            continue
        return false
    }
    return true
}